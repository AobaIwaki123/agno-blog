---
globs: *.py
description: Tools and integrations specific to the Agno blog application
---

# Blog Application Tools & Integrations

## Required Tools

### 1. Web Scraping Tools
```python
from agno.tools.duckduckgo import DuckDuckGoTools
from agno.tools.local_file_system import LocalFileSystemTools
import httpx
from bs4 import BeautifulSoup

class WebScrapingTools:
    """Custom web scraping tools for blog content extraction."""
    
    @staticmethod
    def extract_content(url: str) -> dict:
        """Extract main content from a URL."""
        try:
            response = httpx.get(url, timeout=30)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Remove script and style elements
            for script in soup(["script", "style"]):
                script.decompose()
            
            # Extract title
            title = soup.find('title')
            title_text = title.get_text().strip() if title else "Untitled"
            
            # Extract main content (adjust selectors as needed)
            content_selectors = [
                'article', 'main', '.content', '.post-content', 
                '.entry-content', '[role="main"]'
            ]
            
            content = ""
            for selector in content_selectors:
                element = soup.select_one(selector)
                if element:
                    content = element.get_text().strip()
                    break
            
            if not content:
                # Fallback to body content
                body = soup.find('body')
                content = body.get_text().strip() if body else ""
            
            return {
                "title": title_text,
                "content": content,
                "url": url,
                "status": "success"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}
```

### 2. Content Processing Tools
```python
import re
from typing import List, Dict

class ContentProcessingTools:
    """Tools for processing and structuring extracted content."""
    
    @staticmethod
    def clean_content(content: str) -> str:
        """Clean and normalize content."""
        # Remove extra whitespace
        content = re.sub(r'\s+', ' ', content)
        # Remove special characters that might cause issues
        content = re.sub(r'[^\w\s.,!?;:()\-]', '', content)
        return content.strip()
    
    @staticmethod
    def extract_keywords(content: str, max_keywords: int = 10) -> List[str]:
        """Extract keywords from content."""
        # Simple keyword extraction (can be enhanced with NLP libraries)
        words = re.findall(r'\b\w+\b', content.lower())
        word_freq = {}
        for word in words:
            if len(word) > 3:  # Filter short words
                word_freq[word] = word_freq.get(word, 0) + 1
        
        # Return top keywords
        return sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:max_keywords]
    
    @staticmethod
    def generate_summary(content: str, max_length: int = 200) -> str:
        """Generate a summary of the content."""
        sentences = content.split('.')
        summary = ""
        for sentence in sentences:
            if len(summary + sentence) < max_length:
                summary += sentence + "."
            else:
                break
        return summary.strip()
```

### 3. Template Management Tools
```python
import json
from pathlib import Path
from typing import Dict, Any

class TemplateManagementTools:
    """Tools for managing blog post templates."""
    
    def __init__(self, templates_dir: str = "templates"):
        self.templates_dir = Path(templates_dir)
        self.templates_dir.mkdir(exist_ok=True)
    
    def load_template(self, template_id: str) -> Dict[str, Any]:
        """Load a template by ID."""
        template_file = self.templates_dir / f"{template_id}.json"
        if template_file.exists():
            with open(template_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return None
    
    def save_template(self, template_id: str, template_data: Dict[str, Any]) -> bool:
        """Save a template."""
        template_file = self.templates_dir / f"{template_id}.json"
        try:
            with open(template_file, 'w', encoding='utf-8') as f:
                json.dump(template_data, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"Error saving template: {e}")
            return False
    
    def update_template_from_feedback(self, template_id: str, feedback: str) -> bool:
        """Update template based on user feedback."""
        template = self.load_template(template_id)
        if not template:
            return False
        
        # Process feedback and update template
        # This is where you'd implement the logic to parse feedback
        # and update the template accordingly
        
        return self.save_template(template_id, template)
```

### 4. SEO and Formatting Tools
```python
import re
from typing import List

class SEOFormattingTools:
    """Tools for SEO optimization and content formatting."""
    
    @staticmethod
    def generate_meta_description(content: str, max_length: int = 160) -> str:
        """Generate meta description from content."""
        # Remove HTML tags and clean content
        clean_content = re.sub(r'<[^>]+>', '', content)
        clean_content = re.sub(r'\s+', ' ', clean_content).strip()
        
        if len(clean_content) <= max_length:
            return clean_content
        
        # Truncate at word boundary
        truncated = clean_content[:max_length]
        last_space = truncated.rfind(' ')
        if last_space > max_length * 0.8:  # Only truncate at word if it's not too short
            return truncated[:last_space] + "..."
        
        return truncated + "..."
    
    @staticmethod
    def generate_tags(content: str, title: str) -> List[str]:
        """Generate relevant tags for the blog post."""
        # Combine title and content for tag generation
        full_text = f"{title} {content}".lower()
        
        # Common blog tags (can be expanded)
        common_tags = [
            "technology", "programming", "web development", "python",
            "javascript", "react", "nodejs", "database", "api",
            "tutorial", "guide", "tips", "best practices"
        ]
        
        # Find relevant tags based on content
        relevant_tags = []
        for tag in common_tags:
            if tag in full_text:
                relevant_tags.append(tag)
        
        return relevant_tags[:5]  # Limit to 5 tags
    
    @staticmethod
    def format_for_blog(content: str, title: str) -> str:
        """Format content for blog publication."""
        # Add title
        formatted = f"# {title}\n\n"
        
        # Add content with proper paragraph breaks
        paragraphs = content.split('\n\n')
        for paragraph in paragraphs:
            if paragraph.strip():
                formatted += f"{paragraph.strip()}\n\n"
        
        return formatted
```

## Database Integration

### SQLite Setup
```python
from agno.db.sqlite import SqliteDb
from sqlalchemy import create_engine, Column, String, Text, DateTime, Integer
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

Base = declarative_base()

class BlogPost(Base):
    __tablename__ = "blog_posts"
    
    id = Column(String, primary_key=True)
    title = Column(String, nullable=False)
    content = Column(Text, nullable=False)
    url_source = Column(String)
    template_used = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    tags = Column(Text)  # JSON string
    metadata = Column(Text)  # JSON string
    user_feedback = Column(Text)  # JSON string

# Initialize database
db = SqliteDb(db_file="agno_blog.db")
```

### PostgreSQL Setup (Production)
```python
from agno.db.postgres import PostgresDb
from agno.vectordb.pgvector import PgVector

# Database connection
db_url = "postgresql+psycopg://user:pass@localhost:5432/agno_blog"
db = PostgresDb(db_url=db_url)

# Vector database for knowledge base
vector_db = PgVector(
    db_url=db_url,
    table_name="blog_knowledge",
)
```

## API Integration Tools

### FastAPI Integration
```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Optional, List

app = FastAPI(title="Agno Blog API")

class BlogPostRequest(BaseModel):
    url: str
    template_id: Optional[str] = "default"

class TemplateUpdateRequest(BaseModel):
    template_id: str
    feedback: str

class BlogPostResponse(BaseModel):
    id: str
    title: str
    content: str
    status: str

@app.post("/api/generate-post", response_model=BlogPostResponse)
async def generate_blog_post(request: BlogPostRequest):
    """Generate a blog post from a URL."""
    try:
        # Use the URL processing workflow
        result = await url_workflow.run_async(
            input_data={"url": request.url, "template_id": request.template_id}
        )
        
        if result.status == "success":
            return BlogPostResponse(
                id=result.data["id"],
                title=result.data["title"],
                content=result.data["content"],
                status="success"
            )
        else:
            raise HTTPException(status_code=400, detail=result.message)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/update-template")
async def update_template(request: TemplateUpdateRequest):
    """Update template based on user feedback."""
    try:
        result = await template_workflow.run_async(
            input_data={
                "template_id": request.template_id,
                "feedback": request.feedback
            }
        )
        return {"status": "success", "message": "Template updated successfully"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

## Environment Configuration

### Environment Variables
```python
import os
from typing import Optional

class Config:
    """Application configuration."""
    
    # API Keys
    OPENAI_API_KEY: str = os.getenv("OPENAI_API_KEY", "")
    ANTHROPIC_API_KEY: str = os.getenv("ANTHROPIC_API_KEY", "")
    CO_API_KEY: str = os.getenv("CO_API_KEY", "")
    
    # Database
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite:///agno_blog.db")
    
    # Security
    OS_SECURITY_KEY: str = os.getenv("OS_SECURITY_KEY", "")
    
    # Application
    DEBUG: bool = os.getenv("DEBUG", "False").lower() == "true"
    HOST: str = os.getenv("HOST", "0.0.0.0")
    PORT: int = int(os.getenv("PORT", "8000"))
    
    @classmethod
    def validate(cls) -> bool:
        """Validate required configuration."""
        required_vars = ["OPENAI_API_KEY", "ANTHROPIC_API_KEY"]
        missing = [var for var in required_vars if not getattr(cls, var)]
        
        if missing:
            raise ValueError(f"Missing required environment variables: {missing}")
        
        return True
```

## Error Handling and Logging

### Custom Exception Classes
```python
class BlogApplicationError(Exception):
    """Base exception for blog application."""
    pass

class ContentExtractionError(BlogApplicationError):
    """Error during content extraction."""
    pass

class TemplateUpdateError(BlogApplicationError):
    """Error during template update."""
    pass

class DatabaseError(BlogApplicationError):
    """Database operation error."""
    pass
```

### Logging Configuration
```python
import logging
from logging.handlers import RotatingFileHandler

def setup_logging():
    """Setup application logging."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            RotatingFileHandler('agno_blog.log', maxBytes=10485760, backupCount=5),
            logging.StreamHandler()
        ]
    )
    
    # Set specific loggers
    logging.getLogger("agno").setLevel(logging.INFO)
    logging.getLogger("httpx").setLevel(logging.WARNING)
```

## Testing Utilities

### Test Data Generation
```python
import json
from datetime import datetime

class TestDataGenerator:
    """Generate test data for development and testing."""
    
    @staticmethod
    def create_sample_blog_post() -> dict:
        """Create a sample blog post for testing."""
        return {
            "id": "test-post-1",
            "title": "Sample Blog Post",
            "content": "This is a sample blog post content for testing purposes.",
            "url_source": "https://example.com/sample-article",
            "template_used": "default",
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "tags": ["sample", "test", "example"],
            "metadata": {"word_count": 10, "reading_time": 1}
        }
    
    @staticmethod
    def create_sample_template() -> dict:
        """Create a sample template for testing."""
        return {
            "id": "default",
            "name": "Default Blog Template",
            "content": "# {title}\n\n{content}\n\n---\n*Generated by Agno Blog*",
            "version": "1.0.0",
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "usage_count": 0,
            "feedback_score": 0.0,
            "is_active": True
        }
```
